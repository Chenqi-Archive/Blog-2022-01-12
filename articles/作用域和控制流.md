（符号在作用域内的线性累积）（实际中变量的有限使用（临时变量会很快消亡，而不必长期占用一个符号）（有向无环图的宽度有常数限制））（基于块结构封装性不强）

（Lisp、Haskell纯函数调用的作用域问题）（尤其是递归调用对运行时环境的依赖）

（作用域如何被实现）（编译或解释期符号表）（运行期指针任意内存地址访问）

（内置符号（包括库函数）的使用）（文章中大量充斥未定义的符号）



大多数程序使用模块来维护，比如：作为独立编译单位的`.cpp`，`.py`，`.java`等文件，文件内部的各个类、函数块，函数内部的语句块，等等，形成嵌套结构。

每个块中可以定义变量。变量就是一个标识符号，由程序员赋予意义。变量一旦定义，就可以在后续的操作被使用。块也同时规定了符号的使用范围，在某个块内部定义的符号，在块的外部就变得不可见



变量名符号作为引用。（源代码（编译）层面的引用）



块与块之间通过引用实现数据的访问，从而构成一个整体。



块内所有要用到外部符号，都必须作为参数传递进来。

王垠在文章中批评这种“管道工”的工作会带来麻烦。但充斥着电磁波也会存在干扰。



用自然语言书写的文章也是这样使用块结构组织的。每篇文章是一个单位，文章内部也有子模块和段落结构，文章或段落之间也可以相互引用。







，变量或者函数的定义都有一定的作用范围

每个块结构中可以定义一些变量，变量一旦定义，在这个块

















大多数编程语言，都可以定义全局变量、全局函数，在一个函数内部，则可以定义局部变量。

变量就是一个特别的标识符号。全局符号的作用域为当前文件，而局部符号的作用域是其所在的局部块。一些编程语言中，符号只有在定义之后才能被引用，而且不能重复定义相同的符号。这也就意味着，符号一旦被定义，直到作用域末尾，都是可见的，即便这个作用域跨度相当大，从而在接近作用域末尾的过程中，所有可用的符号会越积越多。直到离开作用域后，所有内部定义的符号才能被清除。（构造和析构过程的类比（垃圾回收））

【图（嵌套的作用域）】



但对于计算机来说，在运行过程中，符号并不存在，只有一些值，或者地址在

类似地，在自然界中，也不存在什么作用域，一切事物的运转都是通过与空间相邻元素的相互作用进行的，比如大脑要能控制手指的运动，必须经过神经元上局部信号向前传导，只是通常这个传导的过程很快，从而看其来大脑可以直接控制肢体。（引力、静电力虽然看上去是长距离的作用，但也可以被认为是通过一些基本粒子在空间中的迁移实现的）

因此换句话说，作用域就是在控制流之上抽象出来的一种高层次的控制，借助底层有限控制范围的组合，高层次可以达到更大的控制范围。



程序员视角下所有的计算都是对引用的计算，符号就是一种引用。

（符号同时具有一定的语义（包括符号的类型，也包括在当前程序步骤中符号的逻辑含义（就是算到这一步时符号表达了什么意义）））

编译之后，会变为对值的计算，





在单台计算机上，由于内存的容量固定，且支持随机存取，解引用的过程几乎可以被忽略。物理内存地址译码的过程就是解引用的过程，可以使用常数时间完成。





但在更大规模的数据库，或者分布式环境中，解引用如何进行实际上是最核心的问题，数据需要被层次化地保存起来，节点需要以合适的拓扑结构组织起来，以便尽可能提高路由和传输的效率。





王垠在文章<a href="http://www.yinwang.org/blog-cn/2013/03/31/purely-functional" target="_blank">函数式语言的宗教</a>中指出Haskell语言对纯函数存在过分苛求。但即便这样，还是会存在作用域干扰的问题，因为可以随意调用一个外部的函数。





本文的“控制流”好像应该被叫做“数据流”，不过无关紧要。

