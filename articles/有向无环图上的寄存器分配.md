寄存器分配可以直接在有向无环图上进行。

<br/>

假设一个函数的参数和返回值均为整数（可以有多个），中间过程完全是对整数的基本运算，没有分支、循环，也没有函数调用。

比如下面这个函数（用C语言描述）：

```c
int f(int a, int b) {
    return (a + b) * (-b);
}
```

它可以用有向无环图来表示：

<img src="assets/register_allocation_on_dag/example_dag.png" height="200px">

其中，每个节点表示一步运算，边表示数据在运算间的传递（也可以认为节点表示这步运算后的结果，边表示运算的先后关系）。`+`和`*`是双目运算符，需要两个输入数据作为源操作数，而`-`只需要一个源操作数，但它们都会产生一个输出结果。可以把`a`和`b`也当作一步运算，表示获取a和b的值。

有向无环图可以充分表达这类函数的计算过程。上图中，`*`运算必须在`+`和`-`运算之后才能进行；在a和b的值都取到之后，`+`和`-`可以同时并行计算，或者在单线程执行环境下，以任意次序先后计算。

对上图的一个拓扑排序序列`ab+-*`，就是单线程环境下对该函数的一种计算顺序，可以用下面的动态图表示：

<img src="assets/register_allocation_on_dag/example_evaluation_sequence_1.gif" height="200px">

其中，节点为绿色表示可以在下一步计算，而为橙色表示已经完成计算，但值还会被后续的计算用到。其余的节点都表示为黑色。

类似地，上图的另一个求值序列`b-a+*`，可以用下面的动态图表示：

<img src="assets/register_allocation_on_dag/example_evaluation_sequence_2.gif" height="200px">

注意到，第一种求值序列最多会同时出现两个橙色节点：`ab`，`b+`，`+-`，而第二种为三个：`ab-`。节点为橙色表示数据接下来还需要被使用，那么橙色节点的数量就表示同时需要保存的整数的个数。

不同的求值序列虽然都可以表达函数的计算过程，但它们在某一时刻需要保存的数据量可能并不相同。这个函数的所有5种拓扑排序序列及其所对应的最大数据量如下表：

<table>
	<tr><td>ab+-*</td><td>2</td></tr>
	<tr><td>ab-+*</td><td>3</td></tr>
	<tr><td>ba+-*</td><td>2</td></tr>
	<tr><td>ba-+*</td><td>3</td></tr>
	<tr><td>b-a+*</td><td>3</td></tr>
</table>
对于更复杂的函数，拓扑排序的方式可能更多，需要维护的数据量也可能更大，那么如何找到一种求值序列，使得在任一时刻需要同时保存的数据量尽可能少？

<br/>

#### 有向无环图上的寄存器分配问题

**输入**：

* 一个有向无环图。

**规则**：

* 每个节点有四种状态：待求值、可求值、已求值、已释放。
* 所有初始节点处于可求值状态，其余节点处于待求值状态。
* 每一步选择一个可求值节点对其求值，该节点随即变为已求值状态，同时检查其余节点：
  * 如果某个待求值节点的所有前驱节点都已求值，则变为可求值状态。
  * 如果某个已求值节点的所有后继节点都已求值，则变为已释放状态。

**输出**：

* 一个拓扑排序序列，使得同时处于已求值状态的节点总数的最大值最小。

<br/>





<br/>

下面考虑一些简单的特殊有向无环图：

###### 单链表：

<img src="assets/register_allocation_on_dag/linked_list.png" width="60%">

拓扑排序序列唯一，需要一个寄存器。

另外注意到，在一条边上插入任意多节点形成单链表，不会影响最终的结果。

###### 完全有向无环图：

<img src="assets/register_allocation_on_dag/complete_dag.png" width="23%">

拓扑排序序列唯一，需要n-1个寄存器。（完全有向无环图包含一个单链表作为子图，因此拓扑排序序列唯一）

###### 离散点集：

<img src="assets/register_allocation_on_dag/seperate_nodes.png" width="60%">

拓扑排序序列有n!种，需要n个寄存器，但排列方式不影响寄存器数目。

<br/>









对原图的一些相关节点构成的子图看作一个节点，这时该问题转化为任务调度问题



#### 最小空间任务调度问题

有多个任务（函数），依赖关系形成有向无环图，每一个任务Ti需要大小为Ii的输入数据，输出大小为Oi的数据，任务结束后输出数据需要临时保存起来，以便后续的任务使用，那么，如何安排各个任务的执行顺序，使得保存数据所需的最大空间最小？













### 讨论：



寄存器分配问题通常被看作图着色问题，这里的图是对线性的三地址代码作变量生命周期分析后得到的干涉图。最少的寄存器个数是这个图的色数。

虽然求图的色数问题是一个NP完全问题，但在这个干涉图上，图的色数可以直接得到，就是最大的同时活跃的变量数。

由于本文只讨论了对于一个简单函数所需的最少寄存器个数的问题，没有涉及spill到内存的情形，在这种情形下，图着色算法其实并不会起到任何作用，并不直接体现了寄存器分配问题，还不是效率最高的算法。

但其实，核心的调度过程就发生在将有向无环图线性化为代码序列的过程中。

这个问题很可能是NP难的，但我还没有证出来。



借助有向无环图定义的寄存器分配问题非常直接，应该早已有人研究过了，但我现在还没有找到任何资料，编译教材（比如龙书）中也从未提及，因此写作本文，欢迎大家提供相关资料或提出宝贵意见。

