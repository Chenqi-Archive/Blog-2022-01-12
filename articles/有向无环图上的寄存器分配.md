寄存器分配可以直接在有向无环图上进行。

<br/>

假设一个函数的参数和返回值均为整数（可以有多个），中间过程完全是对整数的基本运算，没有分支、循环，也没有函数调用。

比如下面这个函数（用C语言描述）：

```c
int f(int a, int b) {
    return (a + b) * (-b);
}
```

它可以用有向无环图来表示：

<img src="assets/register_allocation_on_dag/example_dag.png" height="200px">

其中，每个节点表示一步运算，边表示数据在运算间的传递（也可以认为节点表示这步运算后的结果，边表示运算的先后关系）。`+`和`*`是双目运算符，需要两个输入数据作为源操作数，而`-`只需要一个源操作数，但它们都会产生一个输出结果。可以把`a`和`b`也当作一步运算，表示获取a和b的值。

有向无环图可以充分表达这类函数的计算过程。上图中，`*`运算必须在`+`和`-`运算之后才能进行；在a和b的值都取到之后，`+`和`-`可以同时并行计算，或者在单线程执行环境下，以任意次序先后计算。

对上图的一个拓扑排序序列`ab+-*`，就是单线程环境下对该函数的一种计算顺序，可以用下面的动态图表示：

<img src="assets/register_allocation_on_dag/example_evaluation_sequence_1.gif" height="200px">

其中，节点为绿色表示可以在下一步计算，而为橙色表示已经完成计算，但值还会被后续的计算用到。其余的节点都表示为黑色。

类似地，上图的另一个求值序列`b-a+*`，可以用下面的动态图表示：

<img src="assets/register_allocation_on_dag/example_evaluation_sequence_2.gif" height="200px">

注意到，第一种求值序列最多会同时出现两个橙色节点：`ab`，或者`b+`，或者`+-`，而第二种为三个：`ab-`。节点为橙色表示数据接下来还需要被使用，那么橙色节点的数量就表示同时需要保存的整数的个数。

不同的求值序列虽然都可以表达函数的计算过程，但它们在某一时刻需要保存的数据量可能并不相同。这个函数的所有5种拓扑排序序列及其所对应的最大数据量如下表：

<table>
	<tr><td>ab+-*</td><td>2</td></tr>
	<tr><td>ab-+*</td><td>3</td></tr>
	<tr><td>ba+-*</td><td>2</td></tr>
	<tr><td>ba-+*</td><td>3</td></tr>
	<tr><td>b-a+*</td><td>3</td></tr>
</table>
对于更复杂的函数，拓扑排序的方式可能更多，需要维护的数据量也可能更大，那么如何找到一种求值序列，使得在任一时刻需要同时保存的数据量尽可能少？

<br/>

#### 有向无环图上的寄存器分配问题

**输入**：

* 一个有向无环图。

**规则**：

* 每个节点有四种状态：待求值、可求值、已求值、已释放。
* 所有初始节点处于可求值状态，其余节点处于待求值状态。
* 每一步选择一个可求值节点对其求值，该节点随即变为已求值状态，同时检查其余节点：
  * 如果某个待求值节点的所有前驱节点都已求值，则变为可求值状态。
  * 如果某个已求值节点的所有后继节点都已求值，则变为已释放状态。

**输出**：

* 一个拓扑排序序列，使得同时处于已求值状态的节点总数的最大值最小。

<br/>

这里比较形式化地定义了这个问题。与上面的动态图相对应，节点处于可求值状态表现为绿色，已求值状态为橙色，待求值、已释放都为黑色。开始时，所有起始节点都为绿色，最终，所有终止节点都会变为橙色。输出的拓扑排序序列就是一个求值序列。同时处于已求值状态，也就是橙色节点的最大数目就是完成这个求值序列时，需要同时保存的数据量。

假设用于临时保存数据的容器，即寄存器，有任意多个。每个橙色节点都会占据一个寄存器，每一步求值时，可以选择一个空闲的寄存器保存即将要计算的绿色节点的值，如果该计算会“释放”一个橙色节点，则可以直接使用该橙色节点所占据的寄存器，而不必多占用一个。

这个问题就是要给出完成这样一个计算任务，同时所需的最少寄存器个数，并且给出对应的求值顺序。

不过要注意的是，虽然常见的运算都为双目或者单目运算，从而每个节点最多只有两个前驱节点，但在上述形式化定义中，有向无环图是任意给定的，前驱节点数并没有作出限制。这样定义是为了描述简便，也不会影响实际问题的求解。

<br/>

这个问题看上去有些困难。下面先考虑一些简单的有向无环图：

###### 单链表：

<img src="assets/register_allocation_on_dag/linked_list.png" width="60%">

拓扑排序序列唯一，需要一个寄存器。

另外注意到，在某条边上插入任意多辅助节点形成单链表，不会对结果造成影响。

###### 完全有向无环图：

<img src="assets/register_allocation_on_dag/complete_dag.png" width="23%">

拓扑排序序列唯一，需要n-1个寄存器。（完全有向无环图包含一个单链表作为子图，因此拓扑排序序列唯一）

###### 离散点集：

<img src="assets/register_allocation_on_dag/seperate_nodes.png" width="60%">

拓扑排序序列有n!种，但每种排列都同样需要n个寄存器，任选一种即可。

###### 二叉树：

<img src="assets/register_allocation_on_dag/tree.png" width="60%">

二叉树复杂一些，可以递归计算。

考虑左右两棵子树，根节点求值前需要先对两棵子树完成求值，它们之间没有任何依赖关系，因此可以依次分别求值，结果各自保存在一个寄存器中，再对根节点求值。叶节点只需要一个寄存器。

假设对左右子树求值时各自需要`l`、`r`个临时寄存器。如果先求值左子树，保存左子树的结果同时求值右子树，需要`max{l, r+1}`个寄存器，反之需要`max{r, l+1}`个寄存器。选择寄存器数目较少的方案即可。

下图中每个节点的数字表示对该节点完成求值过程中需要用到的最大临时寄存器个数。满足：`p=min{max{l,r+1}, max{r,l+1}}`。

<img src="assets/register_allocation_on_dag/tree_ordered.png" width="60%">

###### 多叉树：

虽然实际中不会出现多叉树的情形，但多叉树依然值得讨论。与二叉树的递归方法类似，对于有k个分支的多叉树，子树的求值顺序有k!种。

设一种子树求值顺序中，所需寄存器个数依次为`c1, c2, ..., ck `，则在这种排列下，根节点需要`max{c1, c2+1, c3+2, ..., ck+k-1}`个寄存器。

但事实上，不需要遍历每一种子树的排列。利用贪心策略，只需要对各个子树的寄存器数从大到小排序就可以得到子树的求值顺序。对于二叉树的情形也一样，先对所需寄存器较多的子树求值，就可以得到最优解。

下面两图展示了贪心策略的正确性：（左图没有排序；右图从大到小排序，高度比左图少一）

<img src="assets/register_allocation_on_dag/multi_branch_tree_ording.png" width="70%">

###### 多个有向无环图的集合：

<img src="assets/register_allocation_on_dag/separate_subgraphs.png" width="80%">

如果原图是多个不相关的子图的集合，那么同样可以先分别考虑各个子图，再对子图的求值顺序进行排列。

假设共有k个孤立的子图，已经对各个子图求解了该问题，第i个子图求值过程中最少需要ti个临时寄存器，结果需要保存在ri个寄存器里。如果依次对这些子图求值，同时需要`max{t1, r1+t2, r1+r2+t3, ..., r1+r2+...+r_{k-1}+tk}`个寄存器。

如何重新安排子图的求值顺序，使得同时需要的临时寄存器个数尽可能少？

似乎比较难。

ti大、ri小的优先。可能引发矛盾。

那么按照`ti/ri`从大到小排序。（不是最优！有反例！）





###### 二分有向无环图：

<img src="assets/register_allocation_on_dag/bipartite_dag.png" width="45%">













可以把原图的一些节点构成的子图看作一个节点，这时该问题转化为任务调度问题。



#### 最小空间任务调度问题

有多个任务（函数），依赖关系形成有向无环图，每一个任务Ti需要大小为Ii的输入数据，输出大小为Oi的数据，任务结束后输出数据需要临时保存起来，以便后续的任务使用，那么，如何安排各个任务的执行顺序，使得保存数据所需的最大空间最小？







本文并没有给出对该问题的完整解答。





### 讨论：

寄存器分配问题通常被看作图着色问题，这里的图是对线性的三地址代码作变量生命周期分析后得到的干涉图。最少的寄存器个数是这个图的色数。

虽然求图的色数问题是一个NP完全问题，但在这个干涉图上，图的色数可以直接得到，就是最大的同时活跃的变量数。

由于本文只讨论了对于一个简单函数所需的最少寄存器个数的问题，没有涉及spill到内存的情形，在这种情形下，图着色算法其实并不会起到任何作用，并不直接体现了寄存器分配问题，还不是效率最高的算法。

但其实，核心的调度过程就发生在将有向无环图线性化为代码序列的过程中。

这个问题很可能是NP难的，但我还没有证出来。



借助有向无环图定义的寄存器分配问题非常直接，应该早已有人研究过了，但我现在还没有找到任何资料，编译教材（比如龙书）中也从未提及，因此写作本文，欢迎大家提供相关资料或提出宝贵意见。

