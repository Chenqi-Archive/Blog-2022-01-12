寄存器分配可以直接在有向无环图上进行。

假设函数的参数和返回值均为整数（可能有多个），中间过程完全是对整数的基本运算，没有控制流与其它函数调用。比如下面这个函数（用C语言描述）：

```c
int f(int a, int b){
    return (a + b) * (-b);
}
```

它所对应的有向无环图为：

其中，每个



该有向无环图可以很轻松地根据原函数构造出来。在对该函数进行语法解析之后，可以得到一棵完全由表达式组成的语法树。在语义处理阶段，维护一个符号表，

同时可以作相同表达式消除等简单的优化

符号表





类似地，对于任意一个有向无环图，可以定义如下的“寄存器分配问题”：



#### 【有向无环图上的寄存器分配问题】

**输入**：一个有向无环图，并作出如下定义：

* 每个节点有四种状态：不可求值、可求值、已求值、已释放。
* 所有初始节点处于可求值状态，其余节点处于不可求值状态。
* 每一步，选择一个可求值节点对其求值，此时：
  * 该节点变为已求值状态。
  * 检查该节点后继的所有不可求值节点，如果所有前驱节点都已求值，则变为可求值状态。
  * 检查该节点前驱的所有已求值节点，如果所有后继节点都已求值，则变为已释放状态。

**输出**：一个求值序列（即一种拓扑排序序列），使得同时处于已求值状态的节点总数的最大值最小。





一些特殊的有向无环图：









### 讨论：



寄存器分配问题通常被看作图着色问题，这里的图是对线性的三地址代码作变量生命周期分析后得到的干涉图。最少的寄存器个数是这个图的色数。

虽然求图的色数问题是一个NP完全问题，但在这个干涉图上，图的色数可以直接得到，就是最大的同时活跃的变量数。

由于本文只讨论了对于一个简单函数所需的最少寄存器个数的问题，没有涉及spill到内存的情形，在这种情形下，图着色算法其实并不会起到任何作用，并不直接体现了寄存器分配问题，还不是效率最高的算法。

在将有向无环图线性化为代码序列的过程就是一个调度过程。

