寄存器分配可以直接在有向无环图上进行。

<br/>

先讨论一种简单的情况：假设一个函数的参数和返回值均为整数（可以有多个），中间过程完全是对整数的基本运算，没有分支、循环，也没有函数调用。

比如下面这个函数（用C语言描述）：

```c
int f(int a, int b) {
    return (a + b) * (-b);
}
```

它可以用有向无环图来表示：

<img src="assets/register_allocation_on_dag/example_dag.png" height="200px">

其中，每个节点表示一步运算，边表示数据在运算间的传递（也可以认为节点表示这步运算后的结果，边表示运算的先后关系）。

虽然借助这种有向无环图可以完全表达函数的计算过程，但编译器通常需要生成线性的目标代码指令序列，以便在真实的机器上上运行。目标代码的汇编形式因不同的体系结构而异，但在一般情况下，每一条指令只能进行某一种特定的运算，只能引用2或3个寄存器标号或者内存位置作为操作数。对于经常使用的二元运算，比如加减乘除，一种常用的形式是三地址码，指定了两个源操作数和一个目的操作数。

刚才的那个函数就可以通过如下形式来表达（同样使用C语言描述，但每一行只允许作一次运算）：

```c
int f(int a, int b) {
    int t1 = a + b;
    int t2 = -b;
    int t3 = t1 * t2;
    return t3;
}
```

注意到，上面的描述中，除了参数使用的a和b之外，还额外定义了3个临时变量t1，t2和t3，分别对应有向无环图中`+`，`-`和`*`节点。运算`+`，`-`，`*`依次出现，也恰好是有向无环图的一种拓扑排序序列。调换t2和t1所在的行，先计算`-b`，后计算`a+b`，则对应另一种拓扑排序序列，也可以同样描述这一计算过程。

有向无环图就是对计算顺序的充分的表达。一些计算没有依赖关系，从而可以同时完成，比如`+`和`-`运算；而一些运算需要依赖其它运算完成之后才能进行，比如`+`和`*`，以及`-`和`*`。

由于在当前的体系结构中，单核CPU只能串行执行每一条指令，因此即便两个运算可以同时完成，也必须为它们安排一种顺序。





类似地，对于任意一个有向无环图，可以定义如下的“寄存器分配问题”：



#### 【有向无环图上的寄存器分配问题】

**输入**：一个有向无环图，并作出如下定义：

* 每个节点有四种状态：不可求值、可求值、已求值、已释放。
* 所有初始节点处于可求值状态，其余节点处于不可求值状态。
* 每一步，选择一个可求值节点对其求值，此时：
  * 该节点变为已求值状态。
  * 检查该节点后继的所有不可求值节点，如果所有前驱节点都已求值，则变为可求值状态。
  * 检查该节点前驱的所有已求值节点，如果所有后继节点都已求值，则变为已释放状态。

**输出**：一个求值序列（即一种拓扑排序序列），使得同时处于已求值状态的节点总数的最大值最小。





一些特殊的有向无环图：







对原图的一些相关节点构成的子图看作一个节点，这时该问题转化为任务调度问题



#### 【任务调度问题】

有多个任务（函数），依赖关系形成有向无环图，每一个任务Ti需要大小为Ii的输入数据，输出大小为Oi的数据，任务结束后输出数据需要临时保存起来，以便后续的任务使用，那么，如何安排各个任务的执行顺序，使得保存数据所需的最大空间最小？













### 讨论：



寄存器分配问题通常被看作图着色问题，这里的图是对线性的三地址代码作变量生命周期分析后得到的干涉图。最少的寄存器个数是这个图的色数。

虽然求图的色数问题是一个NP完全问题，但在这个干涉图上，图的色数可以直接得到，就是最大的同时活跃的变量数。

由于本文只讨论了对于一个简单函数所需的最少寄存器个数的问题，没有涉及spill到内存的情形，在这种情形下，图着色算法其实并不会起到任何作用，并不直接体现了寄存器分配问题，还不是效率最高的算法。

但其实，核心的调度过程就发生在将有向无环图线性化为代码序列的过程中。

这个问题很可能是NP难的，但我还没有证出来。



借助有向无环图定义的寄存器分配问题非常直接，应该早已有人研究过了，但我现在还没有找到任何资料，编译教材（比如龙书）中也从未提及，因此写作本文，欢迎大家提供相关资料或提出宝贵意见。

