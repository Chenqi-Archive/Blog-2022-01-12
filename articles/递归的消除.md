一些递归函数可以变化为相应的迭代（或者尾递归）版本，从而节省运行时开销。

比如对于下面采用递归定义的阶乘函数：

```c
int frac(int n) {
    if (n <= 0) { return 1; }
    return n * frac(n - 1);
}
```

可以用迭代过程来等价地描述：

``` c
int frac(int n) {
    int result = 1;
    while (n >= 1) {
        result = result * n;
        n = n - 1;
    }
    return result;
}
```

另一种迭代描述方式：

```c
int frac(int n) {
    int result = 1;
    for(int i = 1; i <= n; ++i) {
        result = result * i;
    }
    return result;
}
```

或者使用尾递归来描述。此时需要定义一个辅助的尾递归函数：

```c
int frac_iter(int n, int result){
    if (n <= 0) { return result; }
    return frac_iter(n - 1, result * n);
}

int frac(int n){
    return frac_iter(n, 1);
}
```

或者使用另一种尾递归描述方式（对应于第二种迭代版本）：

```c
int frac_iter(int n, int i, int result){
    if (i > n) { return result; }
    return frac_iter(n, i + 1, result * i);
}

int frac(int n){
    return frac_iter(n, 1, 1);
}
```



对于斐波那契数列函数：

```c
int fib(int n){ 
    if (n <= 1) {return 1;} 
    return fib(n - 1) + fib(b - 2);
}
```

会产生两次递归调用，但也可以采用类似的变换，将其转化为等价的迭代或者尾递归形式。



那么，是不是所有的递归过程都可以转化为迭代过程呢？

*本文只讨论“纯函数”，即与外部执行环境无关（不能访问全局变量，不能作解引用，不能维护局部状态等等），因而输出结果只依赖于传入的参数。*

假设函数将类型T的输入转化为类型R的输出。

该函数可以用以下形式来描述：

```c++
R f(T para){
    if (non_resursion(para)){
        return h1(para);
    }
    
    T t1 = g1(para);
    T t2 = g2(para);
    ...
    T tn = gn(para);
    
    R r1 = f(t1);
    R r2 = f(t2);
    ...
    R rn = f(tn);
    
    return h2(para, r1, r2, ..., rn);
}
```

或者使用更直观的图描述：





比如对于阶乘函数，可以描述为：

```c++
using T = int;
using R = int;

bool less_equal_0(T n){
    return n <= 0;
}

T minus_1(T n){
    return n - 1;
}

R multiply(T n, R r){
    return n * r;
}

R frac(T n){
    if(less_equal_0(n)){
        return 1;
    }
    
    int t = minus_1(n);
    
    int r = frac(t);
    
    return multiply(n, r);
}
```

用图表示为：





每个递归函数必须有非递归的分支用来跳出递归，如果参数落入非递归分支中，结果可以直接计算出来。

同时，递归函数不应该发生循环依赖，否则会出现无限递归。

由于参数是有限的，每个良定义的递归函数最终一定会进入非递归分支中，从而结束递归。





因此，如果函数h满足结合律，或者函数g可逆，递归一定可以转化为非递归，不需要维护中间结果，只需要常数的空间。

在开头对阶乘函数的两种迭代变换中，第一种利用了multiply的结合律，而第二种利用了minus_1的可逆性。









### 讨论

本文只讨论了纯函数，对于非纯函数

CPS变换也可以将递归等控制流转化为尾递归。但CPS只是一种形式上的变换，并没有作任何代数变换，因此虽然看上去所有递归被消除了，但Continuation在传递过程中也会像调用栈一样逐渐膨胀，并不会提高执行效率。

