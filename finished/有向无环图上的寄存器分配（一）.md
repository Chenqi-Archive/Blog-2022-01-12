寄存器分配可以直接在有向无环图上进行。

<br>

假设一个函数的参数和返回值均为整数（可以有多个），中间过程完全是对整数的基本运算，没有分支、循环，也没有函数调用。

比如下面这个函数（用C语言描述）：

```c
int f(int a, int b) {
    return (a + b) * (-b);
}
```

它可以用有向无环图来表示：

<img src="assets/register_allocation_on_dag/example_dag.png" height="200px">

其中，每个节点表示一步运算，边表示数据在运算间的传递（也可以认为节点表示这步运算后的结果，边表示运算的先后关系）。`+`和`*`是双目运算符，需要两个输入数据作为源操作数，而`-`只需要一个源操作数，但它们都会产生一个输出结果。可以把`a`和`b`也当作一步运算，表示获取a和b的值。

有向无环图可以充分表达这类函数的计算过程。上图中，`*`运算必须在`+`和`-`运算之后才能进行；在a和b的值都取到之后，`+`和`-`可以同时并行计算，或者在单线程执行环境下，以任意次序先后计算。

对上图的一个拓扑排序序列`ab+-*`，就是单线程环境下对该函数的一种计算顺序，可以用下面的动态图表示：

<img src="assets/register_allocation_on_dag/example_evaluation_sequence_1.gif" height="200px">

其中，节点为绿色表示可以在下一步计算，而为橙色表示已经完成计算，但值还会被后续的计算用到。其余的节点都表示为黑色。

类似地，上图的另一个求值序列`b-a+*`，可以用下面的动态图表示：

<img src="assets/register_allocation_on_dag/example_evaluation_sequence_2.gif" height="200px">

橙色节点的最大数量表示同时需要保存的整数的最大个数。第一种求值序列最多会同时出现两个橙色节点，而第二种为三个。

不同的求值序列虽然都可以表达函数的计算过程，但它们需要保存的最大数据量可能并不相同。这个函数的所有5种拓扑排序序列及其所对应的最大数据量如下表：

<table>
	<tr><td>ab+-*</td><td>2</td></tr>
	<tr><td>ab-+*</td><td>3</td></tr>
	<tr><td>ba+-*</td><td>2</td></tr>
	<tr><td>ba-+*</td><td>3</td></tr>
	<tr><td>b-a+*</td><td>3</td></tr>
</table>
对于复杂的函数，拓扑排序的方式可能很多，那么如何高效地找到一种求值序列，使得需要同时保存的数据量尽可能少？

#### 有向无环图上的寄存器分配问题

**输入**：

* 一个有向无环图。

**规则**：

* 每个节点有四种状态：待求值、可求值、已求值、已释放。
* 所有初始节点处于可求值状态，其余节点处于待求值状态。
* 每一步选择一个可求值节点对其求值，该节点随即变为已求值状态，同时检查其余节点：
  * 如果某个待求值节点的所有前驱节点都已求值，则变为可求值状态。
  * 如果某个已求值节点的所有后继节点都已求值，则变为已释放状态。

**输出**：

* 一个拓扑排序序列，使得同时处于已求值状态的节点总数的最大值最小。

<br>

这里比较形式化地定义了这个问题。与上面的动态图相对应，节点处于可求值状态表现为绿色，已求值状态为橙色，待求值、已释放都为黑色。开始时，所有起始节点都为绿色，最终，所有终止节点都会变为橙色。输出的拓扑排序序列就是一个求值序列。同时处于已求值状态，也就是橙色节点的最大数目就是这个求值序列完成时，需要同时保存的最大数据量。

假设用于临时保存数据的容器，即寄存器，有任意多个。每个橙色节点都会占据一个寄存器，每一步求值时，可以选择一个空闲寄存器保存即将要计算的绿色节点的值，如果该计算会释放一个橙色节点，则可以直接使用该橙色节点所占据的寄存器，而不必多占用一个。

这个问题就是要给出完成这样一个计算任务，同时所需的最少寄存器个数，并且给出对应的求值顺序。

不过要注意的是，虽然常见的运算都为双目或者单目运算，从而每个节点最多只有两个前驱节点，但在上述形式化定义中，有向无环图是任意给定的，前驱节点数并没有作出限制。这样定义是为了描述简便，也不会影响实际问题的求解。

<br>

这个问题看上去有些困难。下面考虑一些常见的简单的有向无环图：

###### 单链表：

<img src="assets/register_allocation_on_dag/linked_list.png" height="35px">

拓扑排序序列唯一，需要一个寄存器。

另外注意到，在某条边上插入一些节点形成单链表，不会对寄存器分配结果造成影响。

###### 完全有向无环图：

<img src="assets/register_allocation_on_dag/complete_dag.png" height="180px">

拓扑排序序列唯一（因为包含一个单链表作为子图），需要n-1个寄存器。

###### 离散点集：

<img src="assets/register_allocation_on_dag/seperate_nodes.png" height="35px">

拓扑排序序列有n!种，但每种排列都同样需要n个寄存器，任选一种即可。

###### 二叉树：

<img src="assets/register_allocation_on_dag/tree.png" height="250px">

二叉树复杂一些，可以递归计算。

考虑左右两棵子树，根节点求值前需要先对两棵子树完成求值，它们之间没有任何依赖关系，因此可以依次分别求值，结果各自保存在一个寄存器中，再对根节点求值。

假设对左右子树求值时各自需要`l`、`r`个临时寄存器（叶节点需要一个寄存器）。如果先求值左子树，保存左子树的结果同时求值右子树，需要`max{l, r+1}`个寄存器，反之需要`max{r, l+1}`个寄存器。选择两者中寄存器数目较少的方案即可。

下图中每个节点的数字表示对该节点完成求值过程中需要用到的最大临时寄存器个数。满足：`p=min{max{l,r+1}, max{r,l+1}}`。

<img src="assets/register_allocation_on_dag/tree_ordered.png" height="250px">

###### 多叉树：

虽然实际中不存在多叉树的情形，但多叉树依然值得讨论。与二叉树类似，对于有k个分支的多叉树，子树的求值顺序有k!种。

设一种子树求值顺序中，所需寄存器个数依次为`c1, c2, ..., ck `，则在这种排列下，根节点需要`max{c1, c2+1, c3+2, ..., ck+k-1}`个寄存器。

使用贪心策略，最优的子树求值顺序就是对各个子树的寄存器数从大到小排序的顺序。对于二叉树的情形也一样，先对所需寄存器较多的子树求值，就可以得到最优解。

详细证明略，下图展示了贪心策略的正确性：（左图没有排序；右图从大到小排序，高度比左图少一）

<img src="assets/register_allocation_on_dag/multi_branch_tree_ording.png" height="230px">

### 小结

本文定义了有向无环图上的寄存器分配问题，但没有给出完整解答，更多的情形将在下一篇文章<a href="#有向无环图上的寄存器分配（二）">有向无环图上的寄存器分配（二）</a>中讨论。

寄存器分配问题过去通常被人们看作图着色问题，这里的图是对已经化为线性序列的三地址代码作变量生命周期分析后得到的干涉图。最少的寄存器个数是这个图的色数。虽然求一般图的色数是一个NP完全问题，但如果没有分支或循环的话，这个干涉图的色数可以直接得到，就是最大的同时活跃的变量个数。因此图着色并不是寄存器分配问题的一个有效模型，关键的调度过程其实还包括将有向无环图线性化为代码序列的过程。

