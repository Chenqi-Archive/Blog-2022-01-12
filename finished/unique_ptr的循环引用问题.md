以下C++代码会引发内存泄漏：

```c++
struct A {
	std::unique_ptr<A> ptr;
};

void f() {
	std::unique_ptr<A> a = std::make_unique<A>();
	a->ptr = std::move(a);
}
```

（完整代码见：<a href="assets/abstract_tree/unique_ptr_memory_leak.cpp" target="_blank">unique_ptr的内存泄露</a>（使用Visual Studio编译））

<br>

C++中通常使用智能指针shared_ptr、unique_ptr等管理内存对象。shared_ptr管理的对象可以有多个引用，并且通过引用计数记录，当引用计数为0时，对象才被真正销毁。unique_ptr保证它所维护的对象只被自己一人引用，从而不允许复制，只能借助std::move移动，让出对象的所有权，如果析构则会直接销毁对象，释放内存。

一个对象中可能还包含其他对象的引用，当对象析构时，它所引用的对象如果不再能被引用到，就也应该被释放，否则成为内存垃圾。如果使用shared_ptr，程序员需要保证所有对象间的引用关系形成有向无环图；如果使用unique_ptr，则需要保证对象间的引用关系形成树。一旦出现循环引用，比如开头那个例子，就会引发内存泄漏。

C++的内存分配和释放在对象构造和销毁时立即执行，而Java通常不会使用引用计数，而是使用垃圾回收器定期扫描垃圾对象并清除。

<br>

在使用树结构的文件系统中，每个文件或文件夹只由一个父文件夹维护。为了维持树结构，删除文件夹时会递归删除所有的子文件夹，移动文件夹时需要检查移动后是否有可能出现循环引用。比如Windows中，当你试图把一个文件夹移动或复制到它的某个子文件夹中时，系统会阻止你这样操作，同时你可能会看到如下提示框：

<img src="assets/abstract_tree/file_system_folder_structure.png">

直到写这篇文章时，我才意识到会有这个问题，马上尝试了一下，于是生平第一次见到了这个提示框。可以想象，每次移动文件夹时，操作系统都需要遍历目标文件夹的所有父文件夹，检查源文件夹是否是其中的一个，而不能直接移动，即便这样的操作几乎不会出现。

<br>

其实这篇文章的写作动机源于图形界面库的设计。当前每个窗口元素只有一个父窗口，类似于浏览器的dom树。父窗口会用unique_ptr维护子窗口的内存资源，子窗口保存父窗口的弱引用。当窗口添加一个窗口为自己的子窗口时，事实上需要检查这个子窗口是否为自己的某个祖先（包括自己在内），防止出现循环引用。但后来该检查被移除。
