以下C++代码会引发内存泄漏：

```c++
struct A {
	std::unique_ptr<A> ptr;
};

void f() {
	std::unique_ptr<A> a = std::make_unique<A>();
	a->ptr = std::move(a);
}
```

（完整代码见：<a href="assets/abstract_tree/unique_ptr_memory_leak.cpp" target="_blank">unique_ptr的内存泄露</a>（使用Visual Studio编译））

<br>

C++中通常使用智能指针shared_ptr、unique_ptr等管理内存对象。shared_ptr允许对象有多个引用，复制引用时增加引用计数，销毁引用时减少引用计数，直到引用计数为0，才真正销毁这个对象。unique_ptr保证它所维护的对象只被自己一人引用，从而不允许复制，只能借助std::move移动，让出对象的所有权，如果析构则会直接销毁对象，释放内存。

一个对象中可能还包含其他对象的引用，当对象析构时，它所引用的对象如果不再能被引用到，就也应该被释放，否则成为内存垃圾。如果使用shared_ptr，程序员需要保证所有对象间的引用关系形成有向无环图；如果使用unique_ptr，则需要保证对象间的引用关系形成树。一旦出现循环引用，比如开头那个例子，就会引发内存泄漏。

当然在Java中，对象之间可以随意改变引用，没有被引用到的对象会被垃圾回收器定期清除。

<br>

在使用树结构的文件系统中，每个文件或文件夹只由一个父文件夹维护。为了维持树结构，删除文件夹时会递归删除所有的子文件夹，移动文件夹时需要避免出现循环引用。比如Windows中，当你试图把一个文件夹移动或复制到它的某个子文件夹中时，系统会阻止你这样操作，同时你可能会看到如下提示框：

<img src="assets/abstract_tree/file_system_folder_structure.png">

直到写这篇文章时，我才意识到会有这个问题，马上尝试了一下，于是生平第一次见到了这个提示框。可以想象，每次移动文件夹时，操作系统都需要遍历目标文件夹的所有父文件夹，检查源文件夹是否是其中的一个，而不能直接移动，即便这样的操作几乎不会出现。

<br>

我写这篇文章，其实是源于图形界面库的设计。在当前的设计下，每个窗口元素只能有一个父窗口，形成类似于浏览器dom树的组织结构。父窗口用unique_ptr维护子窗口的内存资源，子窗口保存父窗口的弱引用。在窗口添加一个子窗口时，会检查这个子窗口是否为自己的某个祖先（包括自己在内），防止出现循环引用。

