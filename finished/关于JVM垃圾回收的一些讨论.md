与C/C++中由程序员手动分配释放管理内存对象不同，Java使用垃圾回收机制自动判断失去引用的垃圾对象并释放它们的内存。虽然Java标准中没有定义内存布局和垃圾回收的具体实现，但通常的JVM采用的是分代垃圾回收机制。

在程序运行过程中，内存对象不断创建或销毁，它们之间的引用也不断变化，可能形成复杂的图结构。但所有动态内存对象归根到底都被一些静态的内存对象，比如静态变量、栈指针等所引用，这些静态对象就作为根节点，从此出发的所有被引用到的对象都被视为存活的对象。在引用变化过程中，一旦某个或者某些对象失去了全部引用，与根节点不再连通，就会成为内存垃圾。一个形象的例子见<a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/" target="_blank">LeetCode题目：打砖块</a>。

但是，在修改了某个引用之后，一个对象是否变成了内存垃圾很难实时判断，这相当于需要寻找一条从根节点到这个对象的路径，最坏情况需要遍历所有图节点。因此垃圾的扫描通常隔一段时间进行一次，通过从根节点出发的一次性遍历，把这段时间内产生的所有垃圾都找出来并清理掉。

不过大部分对象之间的引用关系都比较简单，很少有循环引用，因此可以使用引用计数直接判断对象是否已经消亡。C++中的智能指针就会借助引用计数实时回收垃圾，但程序员需要保证没有循环引用。Java本可以同时使用引用计数和垃圾扫描，但因为引用计数的维护也会带来额外的存储和更改计数的开销，因此大多JVM并没有采用，而是把全部工作都交给了垃圾扫描。

虽然一些已经成为垃圾的对象不再被根节点所在的连通分支所引用，但这些对象依然会被内存管理器引用到。内存管理器管理着所有对象，不管它存活与否。在垃圾扫描过程中，从根节点出发能到达的对象就会被标记成存活状态，其余的内存管理器会维护但垃圾扫描器没有标记的对象就视为垃圾。如果因为VM的程序漏洞，有内存空间连内存管理器都不知情，那么这段空间就永远都无法被回收，成为内存泄漏。内存管理器提供分配或者释放某个对象空间的接口，而垃圾扫描器负责判断对象是否为垃圾，并通过内存管理器将扫描到的垃圾对象释放掉。

C/C++的运行时库已经实现了一种内存管理器，要实现垃圾回收，只需要知道对象之间的引用关系，因此需要知道一个对象内存空间的各个字段的含义。JVM会在全局保存所有类的定义，并且在每个对象头部保存自己所属的类型，从而垃圾回收器可以知道每一个对象的哪些内存字段实际上是对另一个对象的引用。其实，类型标记只需要由位于根节点的对象维护，其余对象的类型在被访问时可以通过引用得知。所有类型之间可以借助引用关系构建出一个图，在运行时可以根据这个图推断出对象的类型。

<img src="assets/reference_and_object/type_and_object_relation.png" height="170px">

<p class="caption">编译时类型间的引用和运行时对象间的引用</p>

在对象创建时，内存管理器会从空闲内存空间中找出一块分配给这个对象，于是对象获得了一个唯一的内存地址。它被释放后，这块空间会被内存管理器重新标记为空闲空间，可以被再次分配出去。根据内存地址访问一个对象的开销很大，在C/C++中，为了运行效率，对象引用就是这个对象的内存地址，因此一个对象一经分配，它所在的内存地址就不能随意更换，否则所有引用就会失效，因为C/C++中无法得知某个对象到底被谁引用，这些引用也无法实时修改。从而随着对象的分配释放，内存的空闲空间会变得非常碎片化，难以被充分利用。

而对于Java来说，垃圾扫描器可以在定期扫描时知道一个对象被哪些对象引用，此时内存管理器就可以移动对象的内存位置，同时将所有引用更改为新的地址，让空闲内存的碎片合并到一起。但对象的全部引用只有在全图扫描之后才能知道，因此扫描过程中需要临时维护所有对象的地址及引用，这些数据会占用额外的内存空间，直到碎片整理结束后才能释放。

另外一种更简单的做法是，使用一个单独的表维护所有内存对象的内存地址，对象引用为所在表项的下标，类似于Linux系统的文件描述符表或者Windows的句柄分配表。在碎片整理移动对象时只需要修改一次表项中的地址即可。但这样所有对象相当于使用二级引用维护，因此一次对象访问的成本较高。另外，索引表也会占据额外的内存空间，而且中间也会出现无法整理的碎片，只是这些碎片都比较小而且整齐，后续可以再依次分配出去。

<img src="assets/reference_and_object/jvm_object_reference.png">

<p class="caption">The Java® Virtual Machine Specification (Java SE 8 Edition)中关于对象引用结构的说明</p>

垃圾扫描器可以和用户程序同时运行吗？这相当于要保证扫描结束时所有实际存活的对象都能被扫描到。虽然对象间的引用关系可能被用户程序实时更改，但引用的更改是原子性的，因此不需要显式同步。如果扫描过某个对象后，引用发生了更改，新引用到的对象就可能会被遗漏。当然，原先被引用的对象也可能成为垃圾，就只能留到下一次垃圾扫描时处理了。

<img src="assets/reference_and_object/concurrent_garbage_scan_issue.gif" height="150px">

<p class="caption">已经扫描过的对象将引用修改，指向了一个尚未扫描的对象，因而该对象被遗漏</p>

垃圾扫描结束后，内存碎片的整理可以和用户程序同时运行吗？碎片整理涉及到对象内存位置的移动和引用的修改两个步骤。可以先将对象复制到目的地址，再把引用修改为新地址。但这样需要保证空闲空间足够大，从而能放得下一个完整的对象。另外，在复制对象时如果程序修改了对象内的数据，就会造成不一致。因此垃圾回收过程不能与用户程序同时进行。JVM就会在垃圾回收时触发Stop The World，暂停用户程序。

但上面的并发问题都源于用户程序可能会改变对象的引用或数据。如果某个对象是常量，垃圾扫描器或者碎片整理器就可以并发运行。另外，一个对象的大小通常也不会很大，从而在碎片整理时会有足够的空闲空间用于复制。

JVM通常还会使用分代垃圾回收机制。内存区域被划分为新生代和老年代，新创建的对象会放在新生代，如果多次垃圾回收都存活，就会被移入老年代。由于大多数对象的生命周期很短，对新生代的垃圾扫描可以频繁一些，从而可以及时释放大量空间。但如果只扫描新生代，就需要假设所有老年代对象都为根节点，从而需要额外维护老年代对新生代对象的引用。

总之，垃圾回收涉及类型、对象以及存储管理等核心问题，比较复杂。当前所说的垃圾回收一般指的是内存空间的管理，但其实磁盘文件存储，以及版本控制系统也可以实现类似的机制。

