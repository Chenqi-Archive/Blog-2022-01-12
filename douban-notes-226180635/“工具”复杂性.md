我们大概有这样一个常识：**工具所提供的功能越复杂，工具的构造也就越复杂**。比如：自动铅笔可以通过按压出芯，而普通铅笔不行，自动铅笔的构造更复杂；汽车可以高速行驶，同时提供舒适的乘坐环境，而自行车不行，汽车的构造更复杂。

如果把工具看作“黑箱”，工具提供的功能，就是黑箱所暴露的“接口”。自动铅笔的“接口”就是按压的按钮，以及用来书写的笔头；汽车的“接口”是方向盘，一系列操纵杆，也包括乘坐环境等等。而工具的构造，就是黑箱的内部实现，比如自动铅笔内部的弹簧等复杂的机构；汽车的发动机，油箱，电气设备等。

对于工具的发明者来说，工具的内部实现是首要考虑的问题。工具通常由更小的组件构成，这些组成部分往往相互连接，形成复杂的依赖关系，有的起到支持的作用，有的起到信息传递的作用，有的作为接口暴露在外，提供给使用者，但大多数被封装在内部，使用者不必看到。

而对于工具的使用者来说，只需要熟悉工具的接口，就可以充分利用工具的功能。虽然工具内部的实现可以错综复杂，但工具提供的接口往往非常直观清晰。

可是，这与一开始的常识，即“工具所提供的功能越复杂，工具的构造也就越复杂”似乎又有一些矛盾：既然接口这么简单，那么为什么内部实现却如此复杂？接口的复杂性与内部实现的复杂性到底存在什么关系？仅仅通过外部接口，工具的使用者可以完全推断并还原这个工具的内部构造吗？

<br>

**什么是“工具”?**

首先，什么是工具？一般说来，工具是人肢体的延伸，人可以通过操作工具来间接地操作对象，或者完成某件事情。但工具的含义其实可以更加丰富，比如下面一些例子：

- 螺丝刀、扳手、筷子，汽车、手机、电脑、桌椅板凳，等等，这些日常使用的家用或者交通工具。
- 放大镜、显微镜、脑电仪、核磁共振仪等等，这些用于科学研究的仪器设备。
- 一个函数、类、代码文件、库，或者一个应用程序。
- 细胞、各种细胞器、生物体，也算是“工具”。细胞借助细胞膜将内外的环境隔离，并提供了一些用于物质交换和信息传递的通道作为“接口”。
- 语言、文字，可以看作信息存储和交流的工具。
- 社会机构也算是工具，提供售票或者服务窗口作为交互的“接口”，来处理复杂的社会事务。
- 相对于人的大脑，人的肢体也是“工具”，大脑通过肢体来感知和操作对象。
- 一个定理，或者一种证明技巧，应该也可以看作是数学证明的“工具”。
- ……

因此，本文讨论的“工具”，其实更偏向于“结构”，或者说“系统”，**并无褒贬的含义**。

---

**问题提出的背景，以及一些个人经历：**

这个问题是在我之前写代码时思考的。“接口”的概念也来源于编程，每个函数就相当于一个接口，而函数的实现是其内部构造。之前我打算写一个图形界面库，一来练练手，熟悉一下c++的语法和写项目的感觉，我还从没写过什么项目；二来这个图形界面库可以拿来写很多其他程序，其实我本来是想直接写一个小软件的，但现在很多成熟的图形框架都感觉不怎么顺手，要么体积巨大，要么配置复杂，于是就打算自己边练手边先搞一个。

最后这个图形界面库终于做出来了，不算之前漫长的准备工作、试错和体系的设计，写代码的过程就大概花了两个多月的时间。虽然代码量不大，而且还有太多值得改进的部分（我早就有了推倒重做的打算），但做这个项目的收获，以及收获的效率，远远超过上的几门课。我大概熟悉了c++语言的一些特性，了解了Unicode字符集、字体渲染、浏览器工作原理，以及各种Win32API等等，最重要的是，体验了一下构建一个复杂软件工程系统的感觉。许多关于复杂系统的普适性的问题，比如本文要讨论的这个问题，大概就是在这时逐渐想要明确的。

因为要写一个库函数，就必然要考虑哪些由自己做，哪些由库的使用者去做，从而要在中间提供哪些接口。某一天写完代码出去散步的时候，就开始想这个问题，感觉接口和实现的复杂程度不太匹配，既然提供的功能这么简单，为什么实现起来又这么复杂？于是在路上仔细思考了这个问题，大概当时就渐渐想清楚了。

---

**接口的复杂性与内部实现的复杂性到底存在什么关系？**

答案应该就是：**接口的复杂性等于内部实现的复杂性**。

当然，接口和内部实现的复杂性的定义其实是不一样的。“接口”更侧重于信息编码，大概可以通过接口参数的各种可能的排列组合的方式来度量，或是通过接口单位时间传递的信息量来度量，类似于“信道容量”之类的。而内部构造的复杂性，则体现为各个更小的组分的数目，组分自身的复杂性，再加上组分之间相互作用的复杂性，直观上大概可以通过相互作用网络的连边数目等等进行度量。

当然，这些概念现在还非常模糊，仅仅是一种直观上的感觉。不过要从数学上证明这一点，应该也不难，只要对上述复杂性的概念进行更加明确的定义，大概就可以直接得到。其中最关键的步骤应该是从不同的排列组合方式到不同的连接结构的转化。

<br>

**既然接口这么简单直观，那么为什么内部实现却如此复杂？**

**工具的接口，既包括为用户提供的上层接口，也包括工具所依赖的更底层工具的接口。**工具的复杂性由上下两端的接口共同决定。如果工具依赖于某个成熟的组件，那么工具本身就会很简单。用户所见的接口只是上层接口，而面向底层的接口的复杂性，用户毫不知情，从而用户可能会对工具的复杂性造成误判。

同时，用户所经常使用的接口的复杂性有一定的局限。一般的用户不会穷尽所有的功能，只会使用部分功能；而工具的创造者却要考虑各种可能的使用情景。

<br>

**仅仅通过外部接口，工具的使用者可以完全推断并还原这个工具的内部构造吗？**

如果工具的使用者完全理解工具的接口描述，并且知晓工具所依赖的底层组件，那么还原出这个工具应该是没有问题的，但需要一些时间和工作量，这与工具的复杂性大致相当。当然还原出的结果可能与工具原始的实现略有不同。

而且，为了实现某个功能，工具内部可能还会定义一些中间结构作为辅助，尤其是当上下接口的表达方式差距太大的话，中间结构可能占据工具的大部分。这些结构的设计往往难以直接推断。

一种可行的推断方式是分析该工具完成某项任务所需的“关键路径”，即在某个特定的接口参数下，信息的转化需要如何一步步进行，在分析足够多可能的情况之后，工具的内部实现网络可能也就大致勾勒出来了。当然有些情形不可能完全穷尽，因而可能并不能完整地复现。

<br>

**讨论这个问题有什么用呢？**

对于程序设计，或者其他领域，大概可以通过接口所要提供的功能，以及当前已有的可以利用的组件，大致预估要实现的某个模块的复杂性，并初步规划整个模块的框架。

也可以用来优化一些接口并没有对外开放，而内部实现中冗余的部分（这些冗余的部分可能源于没有被充分使用的某个内部依赖组件，或者源于一些历史遗留的淘汰的废弃的功能，等等）。相应地，也可以用来严格化接口的描述，减少某些并没有实现，而在接口中暴露出来的组合方式，避免无效的交互。

<br>

**还有什么问题吗？**

“工具”复杂性与算法复杂性的概念不太一样，一般说的算法复杂性指的是某个算法的时间和空间开销，而本文讨论的结构复杂性有些类似于**Kolmogorov复杂性**（柯氏复杂性，大概指的是用来描述一个对象所需的最少信息量）。

当然，对工具的操作可能存在一些延迟，算法可能会影响延迟时间，这在实际使用中非常重要。

其次，虽然工具的复杂性可以由接口完全决定，但在实际情况中，还可能会存在各种异常，接口也可能会不断动态调整，从而要求工具的设计有一定的冗余度来保证容错性和灵活性。

<br>

本文只是大致探讨了一下某个工具（或者系统）的结构和功能的复杂性的关系。更详细的探究有待之后补充。

<br>

Chenqi

2020/11/26

<br>

**文章使用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享（CC BY-NC-SA 4.0）</a>授权**