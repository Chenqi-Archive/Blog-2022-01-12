过去两年，我唯一称得上收获的东西，大概只有这个图形界面库了，其余时间，可能就真的不明不白地过去，没有留下什么痕迹。因此这篇文章，借着梳理我完成此项目的过程，试图把我这两年来为数不多的思考沉淀下来。虽然它不是一个项目设计文档，但依然不可避免包含很多专业的内容，希望不会太影响你的阅读。

图形界面库，我可以毫不客气地说，是我的标志性成果之一。我甚至觉得自己之后已经不大可能再完成如此精妙的作品了。当然它并没有什么价值，甚至还不能算成熟可用，我也没有办法直接展示给你，但它对我自己来说还是有里程碑式的意义。原本我没料到它会如此耗费我的精力，只想着尽快把这件脏活干完，去做我认为更重要的事，但是这个项目的进程却一波三折，让我欲罢不能，最后它呈现出一片壮丽的景观，为我带来意想不到的收获和满足。

---

**我为什么要做图形界面库**

做这样一个代码项目并不是我原本的目的和兴趣。大二寒假前，我对计算机专业和编程行业完全没有什么认同，只是按部就班完成课程作业，课余的大部分时间，我都在关注脑科学。我下载了很多论文资料，并且自己也在用OneNote记录一些笔记。当时我把所有找到的文献都分类存放在一个树形的目录结构下，但在查找时依然感到不太方便，因为有的论文可能同时涉及多个话题。我当时的直接需求，就是一个可以给每篇翻过的论文打很多类别标签，而后通过这些标签筛选查找的小工具。我也试着找过一些现有的文献管理工具，但感觉都不太符合我的需要。

虽然我的需求其实并不是那么迫切，但寒假在家我没什么事做，也没心情读论文，于是就开始对这个小工具进行比较详细的设计，比如有哪些菜单，用户可以如何操作，程序初次启动后执行哪些流程，要处理那些异常，等等。这个工具必然需要图形界面，而我也只会一点C++，于是我后来就开始跟着B站上VC驿站的视频，学Win32图形界面编程。学完之后我才意识到，纯Win32编程，以及MFC框架都比较老旧，现在已经几乎没有人用了，于是我开始了解其他图形界面框架，比如Qt，以及C#的WPF，但我不太想在学这些新东西上花太多时间，也不太喜欢XML式的描述语言，Web（包括Electron）我感觉比较庞大低效，不太符合一个桌面小工具的定位，所以我就打算自己写一个图形界面库。

后来，我也开始想要做一些其他的工具或平台，比如一个类似于OneNote的可以在任意位置编辑的比较自由的笔记软件，有些像思维导图，可以方便地构建概念之间的联系；或者一个可以用来做项目规划和设计，便于开发者之间交流协同的工具；我甚至还想要构造一种编程语言，使用图形界面来描述程序的层次结构。这些我都做过一些设计和构想。我的图形界面库起名为WndDesign，也是想实现一个可以在用户程序运行时对窗口进行编辑的工具。而且我在早期图形界面库中的很多设计，也都是为了适应这些项目的需要。比如要实现像OneNote这样一个拥有无限大白板的可以自由拖动的区域，我不可能直接创建一个完整的Bitmap保存上面的图像，而是需要构造一种数据结构，将整个区域切分成一些小块（Tiling），能根据当前视窗的位置动态加载相应的块。

总之，正是想象中对这些项目的美好愿景，构成我去做图形界面库的全部动力。从而我也不打算只做一个演示性的项目，在设计之初我的目标就是完全可用，它作为底层的基石，不能出现任何问题。我当时并不认为这件事难做，只想着赶快完成，因为当前已经有很多比较成熟的图形界面框架了，我觉得它也一定可以做出来。

**开发者及开发过程**

图形界面库完全由我个人开发。且正如之前所说，图形界面库经历了三次彻底的重构。最开始我主要在进行一些简单的尝试，编程经验还严重不足；在大二暑假正式写第一版时，我开始熟悉C++语言，逐渐形成自己的代码风格，并且开始思考很多关于项目演进的问题；大三寒假前我开始做第二版，初衷只是对前一版进行设计改进，并且为我的简历提供一个拿得出手的项目经历；大三暑假实习期间，我又开始设计第三版，这个版本则为我带来了纯粹的设计美感，像是一件艺术品，之前几个版本中遇到的困顿大多得到了完美一致的解决。虽然现在依然有一些我觉得不太满意的地方，但它大概已经算达到极致了。

在每个版本上，我都大概用了两个多月的时间。每段时间的前期约一半时间都主要花在设计、查阅资料，以及写一些小的单元测试上，后期开始正式写代码，在实现的过程中逐渐将单元整合起来，同时完善设计的细节，最后的时间进行调试、错误修复，和一些小规模的优化。

设计时比较轻松自由，而写代码和debug，尤其是对照第三方文档调试底层接口的过程，真的是暗无天日，我需要处理各种繁琐的细节。不过当我用更简洁的接口封装之后，写上层代码和设计一样，就更多的是单纯的享受了。有时写代码可以花掉我一整天时间，路上和睡前我都在想这块可以怎么设计，而没有心思做其他事。这样的状态往往能持续几天，但通常不超过一周我就会感到生理性的不适，而被迫借助看书等方式放松调节。

当一个版本完成后，我总是陷入迷茫中。设计之初的动力好像完全消失了，这个项目本身就为我带来即时的满足，我总是想着还能不能再对代码进行一些优化，却已经忘记自己原本的需要。它本来只作为我的工具，但当我倾其所有投入其中之后，它变成我的目的。因此我常常需要一段时间的调整，回到日常生活，才能重新发现自己的需求，找回最初的动力。

**工具和参考资料**

我所有项目的设计草案，都一直在使用OneNote维护。早期我还用纸笔记录了一些关于窗口布局的手绘稿，后来买了一块数位板，全部设计工作就都由OneNote完成，还可以使用不同的颜色区分。原本我计划图形界面库完成后，自己再马上写一个类似的工具取代OneNote，实现自举，但现在也还没有完成。

我自己用的是Windows 10系统，而且只对C++略熟，因此自然而然会想到Win32的C++图形界面开发，还有Visual Studio的强大支持。在早期我还试图把它做成一个跨平台的图形界面库，因此我也参考过Linux等系统下的图形编程框架，比如X Window System，但都觉得没有Win32直接方便，而且我应该也只会用Windows，因此我最终只把平台选定为Win32，打算如果之后确实有跨平台的需求，再作调整。

我在一开始也没有使用任何版本控制工具，直接上手写，当遇到一些较大调整时，我会手动把当前版本的全部文件复制到一个目录中作为备份。直到寒假前做第二版时，我才开始使用Github，用Visual Studio自带的Git工具提交，这大大减轻了我的负担。我后来在构思自己那个项目管理平台时，也重点考虑过版本控制的问题，并比较深入地调查过Git的实现，尤其是存储结构。

C++语言我虽然在专业课上学过，但我并没有完成过什么独立的项目，对C++特性和标准库（STL）完全不熟。在写最初版本时，很多数据结构，比如链表、位图，我都是自己试着手写。后来我开始参考其他开源项目的代码风格，并且偶尔翻一翻STL的源码，在暑假做第一次正式重构时，还买来《Effective C++》细读，再加上不断尝试以及debug的经历，我才开始逐渐熟悉C++的语言特性，规避很多错误和风险，形成了自己的风格。

我参考最多的开源项目，就是Chromium。虽然我并不打算写Web，但我了解过浏览器的实现机制，读过一些介绍性的技术文档，也略翻过源码。比如从DOM树到渲染树再到GPU合成层，分层和Tiling的规则，元素的重排和重绘时机，事件捕获和事件冒泡机制，以及CSS的各种元素样式等，这些都成为我很重要的设计依据。不过在我的图形界面库中，每个元素被叫做窗口，窗口也可以有自己的父窗口和子窗口，但每个窗口有各自的类型，不同类型共用一些一致的接口，但可能定义不同的样式，承担不同的功能，这样样式就不像CSS那样统一，但效率更高。

初期，除了很多数据结构都是我自己手写之外，关于基本图形，比如长方形、椭圆的绘制我也都是使用简单的参数方程逐个像素点绘制，非常低效，没有利用GPU。那时我受到传统Win32编程范式的影响还比较大，绘图时要先创建画笔或者画刷，在某个画布的指定位置画出图案。当我开始想要绘制文字时，就遇到巨大的困难，我需要手动解析TTF字体文件，读取某个字符对应的轮廓，再画到位图上，但TTF文件中还有很多其他的格式信息，有一千页的标准文档，做到这儿我就完全进行不下去了。于是暑假第一次重构时，我扔掉自己的轮子，直接用Direct2D作为底层的绘图接口。那时我开始翻阅大量微软的Docs文档，一个一个函数和结构体点进去，试图理解它们的功能，还自己在下面写一些简单的单元测试，熟悉这些接口。

参考资料和文档的检索，我一般使用Bing，搜索结果中常常出现的StackOverflow，cppreference.com等网站是我最常访问的平台，我通过例子学到不少C++语言特性，并且解决了很多疑问。一些难以直接搜索到的内容，我也会尝试在Github里寻找相关代码。

**设计和实现的协同进化**

一开始，我的所有想法都在设计草稿中体现出来，但我没有任何代码基础，只是单纯凭借过往使用其他产品的经验，构想这个项目大概要满足那些需求，实现什么功能，简单规划一下交互接口，逐渐细化原本模糊的观念。有时我还会用伪代码写一些简单的框架，对各种名词，比如窗口、位图、画布等，进行初步的定义。但在真正去实现时，还是难以下手，而一旦开始做，就又会碰到各种具体的问题。这种总是去寻找突破口，将项目抽丝剥茧逐渐展开的过程，给人一种做数独的感觉。

之前看过的那些资料为我的设计提供了诸多参照，而且我写过的一些简单的单元测试也能大致明确我建立在那些基础之上。我在早期的实现很简单，大概就只是对底层Win32和Direct2D接口的一些包装，但这时我开始尝试对代码进行拆分，不同功能放在不同文件中，并且会去定义一些自己的数据结构，试图遮蔽底层混乱的接口。此后我开始添加一些新的功能，并且随着代码的增长，我开始对文件结构进行调整，重新分割归类，代码库逐渐变得有模有样。但即便我已经有图形界面库这样一个项目经历，在面对一个新项目时，我也不可能知道它最终的模样，因而不可避免地还会经历一次这样的入门步骤，从简单到复杂，边加入新功能，边调整原先的结构。

一些典型的样例完全指导了我的设计过程。OneNote中无限大的白板就是我在第一版设计中考虑的最重要的例子，由此我需要处理窗口的滚动，在滚动过程中窗口图像的缓存，父窗口和子窗口的位置关系，等等，主要侧重于绘图的部分。第二版除了在绘图上比第一版有很大简化之外，我尤其着重考虑了窗口排版的机制，这时我用到的最关键的例子是由文本框组成的列表（a List of TextBox）。当某个文本框的文字内容变化时，文本框的宽度也会发生变化，继而影响列表的宽度，如果文本框的高度超出列表边框的范围，列表右侧还会出现滚动条，此时再一次引发宽度和高度的重新计算。这个复杂的逻辑，成为第二版中窗口重排机制的重要设计依据，当然我也不会忘记之前第一版中的例子，而是试图去寻找公共的逻辑，把所有的例子统合起来。

在编写代码时，我也同样是边实现某些特殊的模块，比如TextBox、ListLayout、OverlapLayout等，边逐渐把核心的框架明确下来。接口固定之后，再添加新的模块时就只需要实现这些接口，当然有时还是会遇到新问题，引发对接口的重新设计。代码具有一种双重的性质，既作为实现，又是设计的一部分。代码结构不仅仅是对程序逻辑的描述，能在被编译之后发挥预期的功能，还在一定程度上指导着项目未来的演进方向。

设计通常比实现更加自由迅捷，主要以广度优先展开，有很大的前瞻性，甚至显得激进。我在设计时曾经构想过很多功能特性，比如窗口是不是可以不只有一个父窗口，从而其内容可以同时在多个位置呈现。一些底层提供的功能，比如Direct2D的旋转放缩等变换，还有任意几何图案的绘制等，这些我也写过简单的样例，但都还没有加入当前版本中。虽然很多可能最终都不会被实现，但这些想象中的特性往往对设计产生影响，帮助我思考得更加全面。

虽然在前期，设计能为实现提供一些指引，但到了后期，代码实现开始有自己独立的演化逻辑，好像脱离了设计的约束，设计因而显得滞后。代码实现面对的是完全具体的问题，严格受到逻辑制约，每走一步都非常实在，因此常常能让很多新的问题暴露出来，而设计时的想法还比较模糊，看上去完美无缺，但实则并没有考虑到那么多限制条件。不过，如果在实现过程中遇到了一些难以解决的矛盾，不知道接下来怎么办，就还得重新回到设计状态中，借助探索得到的新信息，重新把握项目的全貌，移动工作重心，为接下来的实现提供新的指引。因此设计和实现之间互相依赖，共同进化，并不是单向的决策制定和坚决履行。

在实现的后期，基本框架已经确定下来，各个结构之间紧密耦合，所有代码改动都只是微调。尤其是在debug时，会不得不对原本看起来完好的逻辑进行修补。所有在设计和实现过程中遇到的问题，我觉得不满意的地方，或是一些新功能的构想，我都会把它们统一记录在一个地方。其中一些小问题可能会被随时修复，但也会有一些很大的设计问题无法解决。《人月神话》中说，设计的过程熵减，而维护的过程熵增。当局部的改动逐渐增多，代码逻辑开始变得复杂混乱，难以获得清晰的理解，更不用说大规模的调整。

**重构**

因此当逻辑复杂到一定程度时，任何局部的改进都无法顾及整个项目的大局。此时如果出现新的无法抗拒的需求，或者原先的设计存在无法解决的问题，就必然要对整体的代码结构进行重新设计，推倒重来。当然在局部所做的调整也可以看作小规模的重构，但本节所讲的重构更侧重于在整个项目尺度下的设计调整。

重构是一项成本很高的操作，当项目极度复杂时，甚至是根本不可能完成的。我的图形界面库并不算复杂，因此我可以大胆地进行几次彻底的重构。新版本在旧版本的废墟之上重生，前一个版本实现过程中记录下来的那些问题，成为我重新设计的重要参考。重构时，我会选择新开一个代码仓库，从头添加所需的代码，试图尽可能减少原有框架的影响，这样给人感觉也更加清爽。但即便这样我也依然会因大量的重复工作而感到疲惫。

虽然重构过程中整个项目结构重新洗牌，语言和风格被重新定义，功能得到增添或废弃，但很多必要组件都被完全保留下来，携带到下一个版本中。比如在图形界面库中的点、向量、矩形等基本的几何元素，以及绘图对象等，在各个版本中没有明显的区别。这些基本组件通常作为项目的边缘节点，并不承担核心逻辑功能。

图形界面库的第一个版本，已经几乎实现了所有功能，大部分设计元素和逻辑都在此版本中确定下来，而且我也利用这个版本实现过一个简单的桌面软件，我当时甚至已经开始写描述文档，不打算继续更新。这一版开始采用Direct2D作为底层接口，明确定义了窗口结构和样式，在设计之初就着重考虑了如何高效地构建一个无限大的区域。但一开始我想把它写成一个动态链接库，独立提供，目的主要是保护代码的版权，但这为文件结构引入了额外的复杂性，难以灵活地添加新的模块，执行效率低，提供给上层用户的接口也不太方便。

第二版主要将原本位于动态库中的各种类型的窗口移入了静态库，动态库只提供公共部分的逻辑，因此显得精简，同时这个版本重新梳理了一遍窗口结构。第一版过于追求统一，所有窗口都可重叠，每个窗口绘图需要的画板都由父窗口提供，但这在处理不同的窗口类型，尤其是那些子窗口并不重叠的窗口，比如列表时，就很低效，有大量结构需要重复定义。第二版不再采用这样的设计，每个窗口各自选择性地维护自己的画板，父窗口把子窗口也当做图案，因此在合成子窗口时，并不是将子窗口的画板直接复制，而是通过回调获得子窗口要绘制的图案。另外，第二版尤其对窗口的重绘和重排进行了详细设计，这在第一版中并没怎么被考虑，这部分的工作量最大。

第三版则完全使用单一的静态库。第二版中每个窗口要维护自己的客户区、非客户区（包括边框滚动条等），但第三版中把非客户区的元素也作为一个单独的窗口，这样每个窗口的结构就变得很简单，样式被简化，重绘和重排的逻辑也得到进一步优化。第二版中关于重排几大页的设计文档和复杂的流程，这一版重构后只用一页就可以全部描述清楚。这一版本也开始加入C++的模板特性作为样式之一，同时便于类型检查。用户程序的代码格式也更加漂亮，便于调整和演进。前两个版本都有大约一万行代码，但这个版本只有七千行，而功能没有什么损失，反而变得效率更高，使用和修改起来也更加灵活。

**优化**

优化不会影响程序的功能，但使逻辑得到简化。通常出于一些历史因素，或者对需求的过度估计，原本的逻辑可能包含大量没有发挥实质功能老旧代码。重构是一种重要的优化方式，帮助从头梳理项目架构，删繁就简。但大多数情况下彻底的重构都不太可能，优化只能在局部展开。

我在做第一版图形界面库时，就开始意识到程序复杂度的问题。因为我要做的是一个工具库，需要向用户程序提供一些接口，我就在思考接口的复杂性，和我要实现这个工具库本身的复杂性之间到底有什么关系。我当时写了一篇简单的文章讨论这个问题，结论大概是，工具通过对更底层接口的封装，向上层提供新的接口，工具的复杂性就由上下接口的复杂性共同决定。如果某个接口并没有发挥作用，那么相应的实现逻辑就应该被优化掉。

比如手机封装了很多芯片元件作为底层接口，给用户提供一些按钮和触控屏作为上层接口。如果某个功能，比如拍照，用户并不需要，那么手机就不必提供相机应用，从而也可以完全不安装摄像头，这样手机内部的布线还可以得到简化。很多软件也是如此，把大量功能封装在一个臃肿的安装包中，但是大多数用户都用不到。

上过编译课后，我对优化有了更深的体会，编译优化很重要的两个过程是常量传播和死代码消除。如果某个参数的值可以直接在编译期间计算出来，那么一些原本需要分类讨论的情形，就只剩下唯一一种可能，另一种可能实际中完全用不到，就可以放心地删除。我就在想软件的打包发布是否也可以转化为根据用户的特殊需要，自动选择提供哪些组件这种模式。虽然对硬件设备来说，根据每个人的需求定制最简的工具，这个想法不太现实，但这是软件完全可以自动实现的。这时我也意识到开源的重要性，很多软件之所以完整打包很大程度上是出于闭源的需要。

这些想法反过来对我写第三版图形界面库有很大帮助。我不仅开始理解并应用C++的模板机制，这大概就是一种在编译期的求值和分支选择，还开始对一些原先并没有太在意的逻辑进行细致的优化。对于输入法编辑器（IME）的代码优化是一个有趣的例子。我在微软官方的文档中并没有找到IME的详细描述，但通过StackOverflow，我发现Chromium有对IME的完整实现，在早期的版本中我直接将全部约四百行代码复制到项目里，调整了一些接口就装进去用。但在第三版重写时，我试着手动做死代码消除，删到最后竟然只留下了四个函数，只有三十行代码。

优化的一个目标是简化逻辑，提高程序的执行效率，另一个目标是便于开发者理解。通常一个文件目录，或者一个函数的大小都不会太大，只承担某个特定的功能，如果某个相似的逻辑在多处重复出现，则一般使用一个新的函数替代，这样所有函数和文件就有序地组织起来，在修改和debug时会便于快速查找定位。第三版图形界面库就几乎做到了简洁清爽，debug也并没有花费我太多时间。

不过在设计之初接口并没有被完全确定下来，因此还不宜进行优化。接口通常由外部的测试样例锚定，编写测试样例时，我就转变为这个工具库的使用者，会尽可能地为了自己的方便定义接口，然后交给库去修改实现，但这也不能太超出库能满足的范围。因此测试样例和工具本身也在协同进化。在项目的后期，底层代码已经封装好，且大多数计划中的组件都已经实现，我也会开始正式写一个大型用户程序，以对库的各个组件进行系统性的测试。只有当用户程序完成后，库才能算真正成熟可用，后期的维护过程也只可能会作一些微小的改进。只是我到现在还没有完成这样一个用户程序，因此图形界面库尚处于襁褓之中，不知道是否还会再次夭折。

---

这篇文章我从去年国庆节第三版图形界面库完成之后就一直在琢磨构思，列过提纲，并且写过一些小片段。但其中的大多数体会，尤其是关于项目发展的问题，在第一版完成时就已经产生。写这篇文章时，我常常回头翻阅自己之前的设计笔记，感叹自己竟然在这个项目上花费如此多的心血，重复走过这么多弯路，但曾经绝大多数设计最后都被废弃，我也没有得到什么看得见的收获，还是会感到有些得不偿失。要我从自己写的图形界面库，和现有的成熟框架之间进行选择，我也大概会直接选择后者。

而且这篇文章也不太好写，我发现自己还是没有能力把这样具体的经历以一种合适的方式呈现出来，我感到自己的语言空洞乏味，根本无法表达出我当时全身心投入其中的激情，也无法还原出它丰富的细节质感。我本想通过技术性的讨论，抽象出一些我认为一般的经验，但我发现这好像也没有什么意义，因为这些都只是我借助当时留下的笔记所做的事后的审视，没有对我做这个项目本身起到什么作用，遇到一个新的项目，我可能依然会手忙脚乱。但我还是打算把这篇文章发布出来，至少它作为我个人经历的一部分，为我确立自己的位置和话语，体现我自己的创造性。当然，如果你真的对这个项目感兴趣，可以通过Github搜索找到我的所有历史代码，如果还需要设计文档这些一手资料，也可以直接联系我。

图形界面库完全是我的一个个人项目，第三版做完后，我开始怀疑这种项目到底能否由一个团队完成。我甚至有些庆幸没有在第一版做完后就将它大肆宣扬，否则我恐怕还深陷在它的泥潭之中，没有机会进行之后的重构。由此我也可以想象，有多少软件是设计拙劣、漏洞百出，而未经细致打磨优化过的。虽然团队通常比个人能完成更加宏大的事业，但交流的限制也会使得项目变得支离破碎，这就像巴比伦塔一样，是一个永恒的矛盾。

本文讲述的是一个图形界面库，却没有呈现任何图片。我想在下面展示一张我用过的草稿纸的照片。像这样画满矩形的草稿纸，大概有几十张，当然我都已经扔掉了。我原本还打算附上一些设计文档和代码的截图，但又觉得没有什么必要。

<img src="assets/douban_archive_2/WndDesign-draft.webp">

2022.1.8
