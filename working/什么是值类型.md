（值都是引用）（引用是对同类对象的编码（引用的相对作用范围是类型，类型则用字符串编码相区分））（编码就是数据）（引用都是值）





常量不占据存储空间，而变量为了在运行时区分它可以取到的值，需要占用存储空间进行编码。这通常可以使用enum来表达：

```c
enum bool { true, false };
```

在这个例子中，true和false都是常量类型，而bool是变量类型。一个bool类型的变量需要占用1bit空间来判断它现在是true还是false，但true或者false本身并不占用运行时空间。

C++中还有另一种写法，用空类表达常量，用union type (std::variant)表达变量：

```c++
struct true_type {};
struct false_type {};
using bool_type = std::variant<true_type, false_type>;
```

常量和空类型没有任何区别，它们运行时不显式占用存储空间，而只在编译期间发挥作用，编译后便化作程序结构的一部分。运行时所有数据都是变量。

奇怪的是，C++会为空类对象也分配至少1byte的空间，为了确保不同对象有不同的内存地址。但这其实根本没必要，常量不占据空间，因此也不应该存在地址。

<br>

除了enum类型，在大多数编程语言中还有char、int、float等值类型，它们保存的值其实就是对常量的编码，因此都会占用一定的内存空间，比如unsigned char编码了0, 1, ..., 255一共256个常量，占用8bit空间。其实unsigned char完全等价于enum { 0, 1, ..., 255 }。

一些编程语言比如C/C++中还有另一种特殊的值类型T*，它保存的值是内存地址。因为每个占据内存空间的对象都有唯一的地址，反过来根据地址可以唯一确定一个内存对象，从而这种类型又被叫做引用（指针）类型。

但所有值类型其实就是引用类型，bool编码的值就是一个引用，可以动态指向true或者false。

（不对有两步操作：根据引用（编码）定位到值对象，附加的对象）（就是map table）

解码和获取相关对象的操作是自然绑定的



引用存在的意义就是被解引用：

switch(){

}

内存地址在访问是也是一个switch，这是由硬件的地址译码器实现的：

switch(addr){

}





会占据一定的存储空间

对这些基本类型进行组合可以构造更复杂的类型，比如class Point { int x; int y; }

在C/C++中，还可以定义引用类型T*。











王垠在文章《<a href="http://www.yinwang.org/blog-cn/2016/06/08/java-value-type" _target="blank">Java 有值类型吗？</a>》中指出Java的设计中其实只有引用类型，byte、int等原始类型通常被称作值类型，是因为在实现时作了inline优化。一个int对象也完全可以用引用来维护，就像String一样，修改值其实是创建了一个新的对象，并变更引用，原来的对象会被垃圾回收掉。

对叶节点的赋值？

当然王垠主要考虑了赋值的问题。

基本类型本身就是引用，只不过引用的解析方式和正规的引用类型不同。



在源代码中，常量依然会占据空间，比如true_type需要占用9个字符，这是为什么呢？

事实上，源码中的所有信息对于编译后的目标代码来说都是常量，比如函数调用语句就是调用一个函数常量。更进一步，目标代码的

文中主要在讨论数值常量，数值变量作为运行时函数的输入，需要动态提供，而数值常量作为函数参数相当于partial evaluation，其实是在塑造着程序结构。

以下的写法事实上没有区别：（使用常量/使用指定的函数）（所有函数调用f(a)都可以重写成为invoke(f, a)传入一个常量函数地址，类似于汇编格式（基本函数比如add, sub等的调用，被直接编码在指令中））

所有函数调用都相当于对全局常量的引用。函数的定义就相当于对全局常量的定义。函数类型就是接口。函数接口的检查由apply完成。



常量折叠之后的代码就是最简的，输入的编码空间被完全占用。如果某些输入在运行时实际是固定的，那么还可以进一步简化。



汇编代码是由硬件解释执行的！

（源程序代码也可以解释执行）



因此本文的常量折叠与源语言和目标语言无关，在源语言层面完全可以实现常量折叠，之后解释执行。（语言只是程序结构的表达方式而已）（之所以会出现这样的混淆是因为一般所说的编译过程同时发生了常量折叠（优化）和语言翻译，但其实这是两个过程）（因此本文的描述与语言和翻译无关）

（当然程序结构和源代码结构还不一样）（程序结构是不考虑语法分析等步骤的）





（对多余输入的优化是常量折叠，对多余返回的优化是垃圾回收）
