编译过程是将高级语言“翻译”为低级语言的过程。高级语言大多使用通俗易懂的语言格式，结构条理清楚，而低级语言复杂混乱，不易阅读。

下面是一个简单的C代码示例，编译之后的汇编代码（未经优化），以及汇编代码对应的16进制表示的机器码：

```c++
int a = 1, b = 2;
int c = a + b;
```

```assembly
mov dword ptr [rbp+4],1
mov dword ptr [rbp+24h],2
mov eax,dword ptr [rbp+24h]
mov ecx,dword ptr [rbp+4]
add ecx,eax mov eax,ecx
mov dword ptr [rbp+44h],eax
```

```
C7 45 04 01 00 00 00 C7 45 24 02 00 00 00 8B 45 24 8B 4D 04 03 C8 8B C1 89 45 44
```

虽然有些时候可以从编译产生的代码（目标代码）推断出源代码，但在更多情况下，尤其是经过编译优化，甚至加密混淆之后，目标代码就面目全非了，即便目标代码可以正常执行，得到预期的结果，但逆向推断出完整的源代码几乎是不可能的。

那么问题来了，编译过程到底会不会丢失信息呢？**如果有信息丢失，为什么目标代码可以完全实现源代码的预期功能？如果没有信息丢失，为什么从目标代码难以还原出源代码？**

这个问题也是在前几个月写代码时想到的，与“工具复杂性”那篇文章的想法好像也稍微有些相似。

<br>

**编译过程究竟发生了什么？**

虽然还没学过编译原理，不过就我目前所知，编译过程大概经历以下一些步骤：首先忽略所有的注释，将所有的词语转化为有特定含义的标识符（token），再将这些标记组成的语句解析为树状的表达式，进行语义的检查，生成中间代码，最后再生成特定的机器代码。总之，这会是一个非常复杂的过程。

<br>

**源代码和目标代码分别有什么特点？**

源代码（高级语言）通常会有更丰富的关键词定义，可以任意指定变量名称，可以随意添加注释。源代码的结构可以通过特定的符号，比如括号、缩进等，清晰地描述出来，整体来看形成有序的层次结构，比如文件目录的结构、类的结构、函数的代码结构等等。而且平均来看，每个结构的大小都不会超过一定的范围，否则会变得难以阅读。

而目标代码（低级语言）的中的关键词通常更加有限，不同的变量通过特殊的地址序号来区分，而不是以名称来区分，名称只有在少数情形下，比如在链接时，才会被使用；注释与代码的执行无关，因此不会出现。目标代码中也存在函数结构，但并不直观，而且由于所有数据都通过内存地址来指定，数据的结构也很不明显。源代码中大部分有序的结构信息都被“挤压”成难以分辨的一整片。

总之，源代码更偏向与程序员日常使用的自然语言，更便于人理解，而目标代码更偏向于一些操作机器的特定的“命令”。

<br>

**源代码与目标代码之间有什么关系？**

与各国语言之间的翻译略有不同的是，编译过程似乎并不“对称”。源代码和目标代码之间的关系，并不是那么“平等”，而更像是“控制和被控制的”关系，或者说抽象和具体的关系。

高级语言通过对低级语言的“封装”，隐藏了低级语言复杂丑陋的接口，向程序员提供了更加直观的界面。因此高级语言相当于程序员与机器之间的一层中间层，向上提供程序员的操作接口，向下依赖操作机器的接口，程序员通过控制高级语言间接地控制着机器。高级语言的编译器，就是这一中间结构的内部实现，完成了接口信息的传递和转换。

由于高级语言更容易受到人的控制，因而拥有更强的可扩展性。程序员可以通过修改高级语言轻易增删某项功能，或者借助注释说明某项还没有实现的功能。高级语言中的变量名，注释等信息，以及高级语言的结构信息，虽然不会在目标代码中出现，或是在目标代码中变得平整模糊，但这些结构化的语言信息有助于程序员理解代码的功能，从而可以方便地进行修改调整。

<br>

**总结和推广**

因此，高级语言不只描述了当前目标代码的功能，还在某种程度上描述了未来的目标代码的功能。编译过程中，这些为了便于程序员的交流和理解，从而协助程序员在未来对程序进行改进和发展的信息，全部被丢弃了，留下的只是当前程序逻辑所蕴含的程序功能，这些功能信息被完整地转化为机器指令而没有丢失。

简单来说，编译过程保留了当前的程序逻辑，并且将冗余的程序结构进行了合并优化，但与此同时，也损失了程序的可理解性，因而目标代码不便于扩展。目标代码虽然可以实现源代码当前的预期功能，并且可以在一定程度上通过逆向工程进行还原，但因为它只包含了源代码的一部分信息，从而并不足以还原出完整的源代码。

<br>

<br>

那么，在**源代码形成的过程**中，会有“信息丢失”吗？如果考虑整个项目的规划，在代码编写之前，一般需要先进行设计，完成项目文档，项目文档通常直接使用人们能轻松理解的自然语言，辅以一些形式化的描述，指导着代码的编写，因此项目文档通常蕴含着更丰富的信息，也更加灵活便于调整。

<img src="assets/douban_archive/waterfall.png" height="400px">

不过，根据文档编写代码的过程，就不像编译过程那样确定了。事实上，这个过程与文档的编写一样，由人来完成，因而是一个创造性极强的过程。文档的设计者并不需要关注与特定编程语言或是算法有关的信息，只需要对功能和实现方式进行粗略的描述。程序员则需要将这些描述用编程语言的形式表达出来，这像是一个“再创作”的过程，因此需要补充额外的信息。

当然，编译过程实际上也会在源代码的基础上增加信息，仅仅知道源代码，编译器是无法工作的，编译器还必须知道特定机器的目标代码规范的信息，作为向下的“接口”，才能被设计出来。这有些类似于之前在“工具复杂性”中提到的根据上下的接口确定内部构造的过程。当接口确定之后，内部结构就可以完全确定了。由于编译的接口规范，即上层高级语言的标准和下层机器语言的标准，是事先确定的，因此编译器完成的编译过程就是确定的。

与编译过程一样，其实当文档与特定的编程语言完全确定之后，代码可以直接确定，说不定将来会出现一种通过自然语言的文档生成代码的工具，这样估计大部分程序员就失业了（好像已经有类似的工具了，比如GPT-3）。

但是这种工具可能在根本上就无法构造出来，因为在实际中，接口的定义常常是非常模糊的，没有统一可行的标准，无法完全确定。并且由于需求本身就是动态发展的，接口的设计必定会不断变化更新。从而根据文档编写代码的过程是一个严格具有创造性的过程，因为编写代码的过程不会完全受到文档的限制，还会反过来影响文档的形成，促成文档的修改和完善。

那么之前在“工具复杂性”中提到的，根据上下接口确定内部构造的过程，就是一种理想的情形了。虽然下层接口已然存在，但上层接口的定义在一开始并不能完全确定，而需要在结构的构造过程中不断变得清晰，甚至可能因为无法实现而被废弃，转而寻找新的路径。因此，目标的确定与路径的探索过程是相互影响的。如下图：

<img src="assets/douban_archive/exploration.png" height="300px">

<p class="caption">左：理想情况，曲折地实现目标。右：实际情况，在寻找过程中目标变得清晰，但与原本的预期发生偏离</p>

文章的写作过程大概也是这样。虽然写文章之前会事先拟定大概的提纲草稿，但随着文章细节的不断完善，可能会涌现出新的问题，或是推翻原有的预期，或是发现新的可能。

<br>

本文写到这儿，好像就有些偏题了，那么回到正题：在源代码形成的过程中，会丢失信息吗？或者说，通过源代码，可以充分了解代码编写者的意图吗？再换句话说，将代码开源，就是真的“开源”了吗？

大多数开源项目，都有详细完整的文档说明，用简洁易懂的语言和清晰的结构，表达了代码设计过程中的各种细节，而阅读源代码，反而如同阅读编译后的目标代码一样，变得难以直观理解。但随着开源项目的逐渐膨胀，就连文档说明，都变得复杂而难以理解了。只有项目的发起人参与了项目的整个发展过程，通晓项目的各个细节，而项目的使用者，根本难以招架这庞大的复杂性，只能选择了解接口就直接拿来用，可是就连项目提供的接口，都渐渐变得令人眼花缭乱了。因此许多开源项目，当创始人也无心维护之后，就难以再被继承发展下去了。

<br>

那么，在写项目文档的过程中，或者跟一般地，在写学术论文，或者进行任何一项创作的过程中，在教育和传播的过程中，在文化的传承过程中，会有信息丢失吗？可以通过阅读文章，了解作者的真实意图吗？

把生命体想象为编译之后，正在不断运转的“目标代码”，自然科学家面对经历数亿年形成的自然生命，可以通过观察完全了解其运作的机制吗？

<br>

Chenqi

2020/12/18

<br>

<br>

**还有什么问题吗？**

**语言的解析方式。**上面列举的几种代码格式虽然理解的难度不同，但其实，它们都可以看成是字节序列。如果同样使用16进制序列表示下面的代码文本，

```
int a = 1, b = 2; int c = a + b;
```

将会得到：

```
69 6E 74 20 61 20 3D 20 31 2C 20 62 20 3D 20 32 3B 0D 0A 69 6E 74 20 63 20 3D 20 61 20 2B 20 62 3B
```

这与之前的机器码表达方式一致，但内容不同：

```
C7 45 04 01 00 00 00 C7 45 24 02 00 00 00 8B 45 24 8B 4D 04 03 C8 8B C1 89 45 44
```

因此，一段字符串的含义，或者说它所蕴含的信息，与特定的解析方式相关。以不同的解析方式处理序列，会得到不同的结果。因此解析方式本身好像就隐含着信息，这无法在序列内部体现出来，只能是依靠外部的某种机制完成。

比如上面源代码的16进制文本，需要通过ASCII解码，而后才能转化为可见的字符串：

<img src="assets/douban_archive/compile.png" height="300px">

由于编码的信息本身并不足以提供解析的办法，解析的办法只能由外部事先定义，因此“柯氏复杂性”中，要确定某种序列的最小描述长度，需要固定描述所能使用的解析方法，比如某种特定的编程语言。但是奇怪的是，“柯氏复杂性”好像本质上与描述方式无关，因为不同描述方式之间可以使用常数的复杂性进行规约，这需要利用“图灵等价性”。我稍有些难以接受，所有的程序都是图灵等价的吗？规约过程的这个“常数”，有实际意义吗？

当然，对于自然语言，即人们日常所使用的语言来说，背后的“生成和解析系统”，是人在语言学习过程中逐渐建立的。

<br>

**解析过程的时间成本。**“柯氏复杂性”仅仅描述了表示的空间复杂性，解析过程需要的时间，或者说解析算法的时间复杂度，并没有被考虑。即便可以完整地还原出原始信息，还原过程也需要一定的时间成本，或者说“工作量证明”，可以看作解析信息的“难度”。

信息解析的难度、“门槛”，难道不也会影响信息的获取吗?这与人为删除某些信息，对于实际效果来说，有任何区别吗？把文章发表出来，别人就真的想去看吗？即便想看，就真的能看懂吗？即便能看懂，就真的有价值吗？即便有价值，就真的比花同样的时间去做其他事更有价值吗？

<br>

文章使用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享（CC BY-NC-SA 4.0）</a>授权